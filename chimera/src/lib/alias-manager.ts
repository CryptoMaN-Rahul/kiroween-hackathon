/**
 * Alias Manager for Symbiote Router
 * 
 * Manages permanent URL aliases that bypass semantic matching.
 * Supports automatic alias creation based on redirect frequency.
 * 
 * @module alias-manager
 */

import type { Alias, AliasStore } from '@/types';

/**
 * Default threshold for auto-creating aliases.
 */
export const DEFAULT_ALIAS_THRESHOLD = 3;

/**
 * In-memory alias store.
 * In production, this would be backed by a database.
 */
let aliasStore: AliasStore = {
  aliases: [],
  redirectCounts: {}
};

/**
 * Generates a unique alias ID.
 */
function generateAliasId(): string {
  return `alias_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Gets all aliases.
 */
export function getAliases(): Alias[] {
  return [...aliasStore.aliases];
}

/**
 * Gets an alias by its source path.
 */
export function getAlias(fromPath: string): Alias | null {
  return aliasStore.aliases.find(a => a.fromPath === fromPath) || null;
}

/**
 * Checks if an alias exists for a path.
 */
export function hasAlias(fromPath: string): boolean {
  return aliasStore.aliases.some(a => a.fromPath === fromPath);
}

/**
 * Gets the target path for an alias.
 */
export function resolveAlias(fromPath: string): string | null {
  const alias = getAlias(fromPath);
  if (alias) {
    // Update hit count and last used
    alias.hitCount++;
    alias.lastUsedAt = new Date();
    return alias.toPath;
  }
  return null;
}

/**
 * Creates a new alias.
 */
export function createAlias(
  fromPath: string, 
  toPath: string, 
  autoGenerated: boolean = false
): Alias {
  // Check if alias already exists
  const existing = getAlias(fromPath);
  if (existing) {
    throw new Error(`Alias already exists for path: ${fromPath}`);
  }

  const alias: Alias = {
    id: generateAliasId(),
    fromPath,
    toPath,
    hitCount: 0,
    createdAt: new Date(),
    lastUsedAt: new Date(),
    autoGenerated
  };

  aliasStore.aliases.push(alias);
  
  // Clear redirect count since we now have an alias
  delete aliasStore.redirectCounts[`${fromPath}::${toPath}`];

  return alias;
}

/**
 * Deletes an alias.
 */
export function deleteAlias(fromPath: string): boolean {
  const index = aliasStore.aliases.findIndex(a => a.fromPath === fromPath);
  if (index === -1) {
    return false;
  }
  aliasStore.aliases.splice(index, 1);
  return true;
}

/**
 * Updates an alias's target path.
 */
export function updateAlias(fromPath: string, newToPath: string): Alias | null {
  const alias = getAlias(fromPath);
  if (!alias) {
    return null;
  }
  alias.toPath = newToPath;
  return alias;
}

/**
 * Tracks a redirect for potential auto-alias creation.
 * Returns true if an alias was auto-created.
 */
export function trackRedirect(
  fromPath: string, 
  toPath: string, 
  threshold: number = DEFAULT_ALIAS_THRESHOLD
): boolean {
  // Don't track if alias already exists
  if (hasAlias(fromPath)) {
    return false;
  }

  const key = `${fromPath}::${toPath}`;
  const count = (aliasStore.redirectCounts[key] || 0) + 1;
  aliasStore.redirectCounts[key] = count;

  // Auto-create alias if threshold reached
  if (count >= threshold) {
    createAlias(fromPath, toPath, true);
    return true;
  }

  return false;
}

/**
 * Gets the current redirect count for a path pair.
 */
export function getRedirectCount(fromPath: string, toPath: string): number {
  return aliasStore.redirectCounts[`${fromPath}::${toPath}`] || 0;
}

/**
 * Gets all redirect counts (for debugging/analytics).
 */
export function getAllRedirectCounts(): Record<string, number> {
  return { ...aliasStore.redirectCounts };
}

/**
 * Gets aliases sorted by hit count (most used first).
 */
export function getAliasesByUsage(): Alias[] {
  return [...aliasStore.aliases].sort((a, b) => b.hitCount - a.hitCount);
}

/**
 * Gets auto-generated aliases only.
 */
export function getAutoGeneratedAliases(): Alias[] {
  return aliasStore.aliases.filter(a => a.autoGenerated);
}

/**
 * Gets manually created aliases only.
 */
export function getManualAliases(): Alias[] {
  return aliasStore.aliases.filter(a => !a.autoGenerated);
}

/**
 * Gets alias statistics.
 */
export function getAliasStats(): {
  total: number;
  autoGenerated: number;
  manual: number;
  totalHits: number;
  pendingAliases: number;
} {
  const aliases = aliasStore.aliases;
  return {
    total: aliases.length,
    autoGenerated: aliases.filter(a => a.autoGenerated).length,
    manual: aliases.filter(a => !a.autoGenerated).length,
    totalHits: aliases.reduce((sum, a) => sum + a.hitCount, 0),
    pendingAliases: Object.keys(aliasStore.redirectCounts).length
  };
}

/**
 * Clears all aliases and redirect counts.
 */
export function clearAliases(): void {
  aliasStore = {
    aliases: [],
    redirectCounts: {}
  };
}

/**
 * Exports aliases as JSON for persistence.
 */
export function exportAliasesAsJson(): string {
  return JSON.stringify(aliasStore, (key, value) => {
    if (value instanceof Date) {
      return value.toISOString();
    }
    return value;
  }, 2);
}

/**
 * Imports aliases from JSON.
 */
export function importAliasesFromJson(json: string): number {
  try {
    const data = JSON.parse(json) as {
      aliases: Array<Omit<Alias, 'createdAt' | 'lastUsedAt'> & { 
        createdAt: string; 
        lastUsedAt: string 
      }>;
      redirectCounts: Record<string, number>;
    };

    let imported = 0;
    
    for (const alias of data.aliases) {
      if (!hasAlias(alias.fromPath)) {
        aliasStore.aliases.push({
          ...alias,
          createdAt: new Date(alias.createdAt),
          lastUsedAt: new Date(alias.lastUsedAt)
        });
        imported++;
      }
    }

    // Merge redirect counts
    for (const [key, count] of Object.entries(data.redirectCounts)) {
      aliasStore.redirectCounts[key] = Math.max(
        aliasStore.redirectCounts[key] || 0,
        count
      );
    }

    return imported;
  } catch {
    return 0;
  }
}

/**
 * Validates an alias has all required fields.
 */
export function validateAlias(alias: Alias): boolean {
  return (
    typeof alias.id === 'string' &&
    alias.id.length > 0 &&
    typeof alias.fromPath === 'string' &&
    alias.fromPath.startsWith('/') &&
    typeof alias.toPath === 'string' &&
    alias.toPath.startsWith('/') &&
    typeof alias.hitCount === 'number' &&
    alias.hitCount >= 0 &&
    alias.createdAt instanceof Date &&
    alias.lastUsedAt instanceof Date &&
    typeof alias.autoGenerated === 'boolean'
  );
}
