/**
 * Property-Based Tests for Alias System
 * 
 * **Feature: chimera-ai-first-edge, Property 5: Alias Learning Threshold**
 * **Feature: chimera-ai-first-edge, Property 6: Alias Priority Over Semantic Matching**
 * **Feature: chimera-ai-first-edge, Property 7: Alias Deletion Restores Semantic Matching**
 * **Validates: Requirements 2.1, 2.2, 2.4**
 */

import { describe, it, expect, beforeEach } from 'vitest';
import * as fc from 'fast-check';
import {
  getAliases,
  getAlias,
  hasAlias,
  resolveAlias,
  createAlias,
  deleteAlias,
  trackRedirect,
  getRedirectCount,
  clearAliases,
  getAliasStats,
  validateAlias,
  exportAliasesAsJson,
  importAliasesFromJson,
  DEFAULT_ALIAS_THRESHOLD
} from '@/lib/alias-manager';

const FC_CONFIG = { numRuns: 100 };

const pathArb = fc.string({ 
  minLength: 1, 
  maxLength: 20,
  unit: fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz0123456789'.split(''))
}).map(s => '/' + s);

describe('Property 5: Alias Learning Threshold', () => {
  beforeEach(() => clearAliases());

  it('alias is NOT created before threshold is reached', () => {
    fc.assert(
      fc.property(
        pathArb,
        pathArb,
        fc.integer({ min: 1, max: DEFAULT_ALIAS_THRESHOLD - 1 }),
        (fromPath, toPath, redirectCount) => {
          clearAliases();
          
          for (let i = 0; i < redirectCount; i++) {
            trackRedirect(fromPath, toPath);
          }
          
          expect(hasAlias(fromPath)).toBe(false);
          expect(getRedirectCount(fromPath, toPath)).toBe(redirectCount);
        }
      ),
      FC_CONFIG
    );
  });

  it('alias IS created when threshold is reached', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        
        for (let i = 0; i < DEFAULT_ALIAS_THRESHOLD; i++) {
          trackRedirect(fromPath, toPath);
        }
        
        expect(hasAlias(fromPath)).toBe(true);
        const alias = getAlias(fromPath);
        expect(alias?.toPath).toBe(toPath);
        expect(alias?.autoGenerated).toBe(true);
      }),
      FC_CONFIG
    );
  });

  it('custom threshold is respected', () => {
    fc.assert(
      fc.property(
        pathArb,
        pathArb,
        fc.integer({ min: 2, max: 10 }),
        (fromPath, toPath, threshold) => {
          clearAliases();
          
          // Track threshold - 1 times (should not create alias)
          for (let i = 0; i < threshold - 1; i++) {
            trackRedirect(fromPath, toPath, threshold);
          }
          expect(hasAlias(fromPath)).toBe(false);
          
          // One more should create the alias
          trackRedirect(fromPath, toPath, threshold);
          expect(hasAlias(fromPath)).toBe(true);
        }
      ),
      { numRuns: 50 }
    );
  });
});

describe('Property 6: Alias Priority Over Semantic Matching', () => {
  beforeEach(() => clearAliases());

  it('resolveAlias returns target path when alias exists', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        createAlias(fromPath, toPath);
        
        const resolved = resolveAlias(fromPath);
        expect(resolved).toBe(toPath);
      }),
      FC_CONFIG
    );
  });

  it('resolveAlias returns null when no alias exists', () => {
    fc.assert(
      fc.property(pathArb, (path) => {
        clearAliases();
        expect(resolveAlias(path)).toBeNull();
      }),
      FC_CONFIG
    );
  });

  it('alias hit count increments on resolve', () => {
    fc.assert(
      fc.property(
        pathArb,
        pathArb,
        fc.integer({ min: 1, max: 10 }),
        (fromPath, toPath, resolveCount) => {
          clearAliases();
          createAlias(fromPath, toPath);
          
          for (let i = 0; i < resolveCount; i++) {
            resolveAlias(fromPath);
          }
          
          const alias = getAlias(fromPath);
          expect(alias?.hitCount).toBe(resolveCount);
        }
      ),
      FC_CONFIG
    );
  });

  it('hasAlias correctly identifies existing aliases', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        
        expect(hasAlias(fromPath)).toBe(false);
        createAlias(fromPath, toPath);
        expect(hasAlias(fromPath)).toBe(true);
      }),
      FC_CONFIG
    );
  });
});

describe('Property 7: Alias Deletion Restores Semantic Matching', () => {
  beforeEach(() => clearAliases());

  it('deleteAlias removes the alias', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        createAlias(fromPath, toPath);
        
        expect(hasAlias(fromPath)).toBe(true);
        const deleted = deleteAlias(fromPath);
        expect(deleted).toBe(true);
        expect(hasAlias(fromPath)).toBe(false);
      }),
      FC_CONFIG
    );
  });

  it('deleteAlias returns false for non-existent alias', () => {
    fc.assert(
      fc.property(pathArb, (path) => {
        clearAliases();
        expect(deleteAlias(path)).toBe(false);
      }),
      FC_CONFIG
    );
  });

  it('after deletion, resolveAlias returns null', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        createAlias(fromPath, toPath);
        deleteAlias(fromPath);
        
        expect(resolveAlias(fromPath)).toBeNull();
      }),
      FC_CONFIG
    );
  });

  it('after deletion, new redirects can create new alias', () => {
    fc.assert(
      fc.property(pathArb, pathArb, pathArb, (fromPath, toPath1, toPath2) => {
        clearAliases();
        
        // Create and delete first alias
        createAlias(fromPath, toPath1);
        deleteAlias(fromPath);
        
        // Track redirects to new target
        for (let i = 0; i < DEFAULT_ALIAS_THRESHOLD; i++) {
          trackRedirect(fromPath, toPath2);
        }
        
        // New alias should be created
        expect(hasAlias(fromPath)).toBe(true);
        expect(getAlias(fromPath)?.toPath).toBe(toPath2);
      }),
      FC_CONFIG
    );
  });
});

describe('Alias System Additional Properties', () => {
  beforeEach(() => clearAliases());

  it('validateAlias returns true for valid aliases', () => {
    fc.assert(
      fc.property(pathArb, pathArb, (fromPath, toPath) => {
        clearAliases();
        const alias = createAlias(fromPath, toPath);
        expect(validateAlias(alias)).toBe(true);
      }),
      FC_CONFIG
    );
  });

  it('export and import preserves aliases (round-trip)', () => {
    fc.assert(
      fc.property(
        fc.array(fc.tuple(pathArb, pathArb), { minLength: 1, maxLength: 5 }),
        (pathPairs) => {
          clearAliases();
          
          // Create unique aliases
          const uniquePairs = pathPairs.filter((pair, i) => 
            pathPairs.findIndex(p => p[0] === pair[0]) === i
          );
          
          for (const [from, to] of uniquePairs) {
            createAlias(from, to);
          }
          
          const exported = exportAliasesAsJson();
          clearAliases();
          
          const imported = importAliasesFromJson(exported);
          expect(imported).toBe(uniquePairs.length);
          
          for (const [from, to] of uniquePairs) {
            expect(hasAlias(from)).toBe(true);
            expect(getAlias(from)?.toPath).toBe(to);
          }
        }
      ),
      { numRuns: 50 }
    );
  });

  it('getAliasStats returns accurate counts', () => {
    fc.assert(
      fc.property(
        fc.array(fc.tuple(pathArb, pathArb, fc.boolean()), { minLength: 1, maxLength: 10 }),
        (aliasData) => {
          clearAliases();
          
          const uniqueData = aliasData.filter((d, i) => 
            aliasData.findIndex(x => x[0] === d[0]) === i
          );
          
          for (const [from, to, auto] of uniqueData) {
            createAlias(from, to, auto);
          }
          
          const stats = getAliasStats();
          expect(stats.total).toBe(uniqueData.length);
          expect(stats.autoGenerated).toBe(uniqueData.filter(d => d[2]).length);
          expect(stats.manual).toBe(uniqueData.filter(d => !d[2]).length);
        }
      ),
      { numRuns: 50 }
    );
  });
});
